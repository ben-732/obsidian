The goal is to develop control protocols that assure serialisability, 

- Schedules must be conflict serialisable, and recoverable, for the sake of database consistency, and preferably cascade-less.
- A policy in which only one transaction can execute at a time generates serial schedules but provides a poor degree of concurrency.
- Concurrency-control schemes have a tradeoff between degree of concurrency and amount of overhead.
- Tests for serialisability help us understand why a concurrency control protocol is correct.

![[Pasted image 20240523151035.png | center | 300]]
### Locks
Serialisability can be enforced through the use of [[08 Concurrent Programming#Read-Writer Lock|locks]]. 

- Transactions must be consistent, actions and locks must relate in expected ways. 
- A transaction can only read or write an element if it has an active lock on the element 
- If a transaction locks an element, it must later unlock that element. 
- No two transactions may have locked the same element without one having released the lock first.
    
![[Pasted image 20240523151205.png | center | 300]]

### Locking Protocols
For a given locking protocol, A schedule $S$ is legal under if it can be generated by a set of transactions that follow the protocol. 

A protocol ensures serialisability if all legal schedules under that protocol are serialisable

#### Binary Locks
This is similar to a mutex

Data items can be locked in two modes :  
- Locked(1): item cannot be accessed  
- Unlocked(0): item can be accessed when requested. 

Two operations 
- lock_item(X)
- unlock_item(X)

Both operations are atomic

#### Share/exclusive protocol
Similar to 370 Reader/writer lock

Shared/exclusive or read/write locks:  
- Read operations on the same item are not conflicting 
- Must have an exclusive lock to write

Three locking operations in a transaction $T$:  
‚Ä¢ `read_lock(X)`: attempt to request a read lock (denoted as ls($X$))  
‚Ä¢ `write_lock(X)`: attempt to request a write lock (denoted as lx($X$))  
‚Ä¢ `unlock(X)`: release the lock $T$ currently holds on $X$ (denoted as u($X$))

If a transaction holds a lock already it is allowed to convert its state. Upgrade/downgrade by preforming the appropriate ls or lx operation. 


#### Two phase lock protocol
Using locking techniques does not always guarantee serialisability, Two phase locking protocol is used to fix this.

There are two phases 
1. Expanding (growing) phase:  
    - Transaction may obtain locks  
    - Transaction may not release locks
2. Shrinking phase:  
    - Transaction may release locks  
	-  Transaction may not obtain locks

It can be proved that the transactions can be serialised in the order of their lock points. 
- The point where a transaction acquired its final lock.

Two-phase locking may limit the amount of concurrency that can occur in a schedule

Some serialisable schedules will be prohibited by two-phase locking 

![[Pasted image 20240523153225.png | center | 300]]
##### 2PL Variations
- Basic 2PL, as described above
- Conservative (static) 2PL: Requires transaction to lock all the items it accesses before the transaction begins. Predeclare read-set and write-set.
- Strict 2PL: Transaction does not release exclusive locks until after it commits or aborts
- Rigorous 2PL: Transaction does not release any locks until after it commits or abort. 

![[Pasted image 20240523153421.png | Center | 300]]

##### 2PL Drawbacks
Basic 2PL ensures Conflict Serializability but does not prevent Cascading Rollback and Deadlock. 

Example: Given two transactions T1 and T2 and the schedule below
Schedule S: 
- Lock-X1(A) 
- Lock-X2(B) 
- Lock-X1(B) 
- Lock-X2(A)

Basic 2PL does not ensure recoverability which can be resolved by strict/rigorous 2PL
It does not ensure cascades schedules which can also be resolved by strict/rigorous 2PL
It is vulnerable to deadlock which can be resolved by conservative 2PL.

#### Update Locking Protocol
Three lock modes, shared, exclusive and *update*. This is because deadlock things in 2PL

- `uli(x)` grants `Ti` the right to read $X$ but not write. However only `uli(x)` can be upgraded to `wi(x)` while `ri(x)` cannot
- Update lock looks like a shared lock when we are requesting it and looks like exclusive lock when we already have it. Denote by U the update lock mode

Shared lock cannot upgrade self to exclusive lock. 


![[Pasted image 20240523160948.png | center | 300]]

#### Increment Locking Protocol
Many transactions operate on the database only by incrementing or decrementing stored values. 

For example, consider a transaction that transfers money from one bank account to another. The useful property of increment actions is that they commute with each other.

Increment Lock $\text{inc}_{i}(X)$, denoted by I the increment lock mode

![[Pasted image 20240523154634.png | center | 400]]

#### Multiple Granularities
- A hierarchy of data granularities, where the small granularities are nested within larger ones
- Granularity of locking (level in tree where locking is done):
    - Fine granularity (lower in tree): high concurrency, high locking overhead
    - Coarse granularity (higher in tree): low locking overhead, low concurrency

**Intention locks**. Transaction indicates along the path from the root to the desired node, what type of lock (shared or exclusive) it will require from one of the node‚Äôs descendants.

![[Pasted image 20240523161632.png | Center | 500]]

Intention lock types  
- Intention-Shared (IS): Shared locks will be requested on a descendant node
- Intention-Exclusive (IE): Exclusive locks will be requested on a descendant node
- Shared-Intension-Exclusive(SIX): The current node is locked in shared node, but one more exclusive locks will be requested on a descendant node.

Original lock types
- Shared (S): Shared lock is requested on the entire subtree of the node
- Exclusive (X) Exclusive lock is requested on the entire subtree of the node. 
![[Pasted image 20240523162001.png | center | 300]]


### Locking Scheduler
The transactions themselves do not request locks or cannot be relied upon to do so.

It is the job of the *scheduler* to insert lock actions into the stream of reads, writes and other actions that access data.

Transactions also do not release locks, the scheduler releases the locks when the transaction manager tells it that the transaction will commit or abort.

![[Pasted image 20240523162141.png | center | 300]]

Part I inserts appropriate lock actions for database access actions (choose lock mode)

Part II executes the sequence of lock and database access actions passed by Part I; assume that the current operation $o$ is on $T$ :

- If $o$ is to acquire a lock for transaction $T$ , Look at the lock table
	- If one cannot be granted, put the request of $T$ to the lock table, notify Part I to delay $T$
	- Grant the lock to T and update the lock table
- If keys requested so far by $T$ have been granted and $o$ is a db access operation then execute.
- Commits/aborts a transaction $T$
	- Notify Part I and release all locks held by $T$. If any transactions are waiting for any of these locks, Part I notifies Part II.
- If notified by Part I that the lock on element X has been released, pick the next transaction T in the waiting list to lock X, notify Part I to resume T

### Locks for Concurrency Control in Indexes
Insertion: When new data item is inserted, it cannot be accessed until after the operation is completed

Deletion operation on the existing data item: write lock must be obtained before deletion

**Phantom revisited**
Phantom can occur when a new record being inserted satisfies a condition that a set of records accessed by another transaction must satisfy

The record that causes conflict is not recognised by concurrency control protocol

## Starvation and Deadlock
Starvation: a transaction cannot proceed for an indefinite period of time while other transactions continue normally.

- Solution: first-come-first-serve queue for each lock (waiting list)

Deadlock: a set $S$ of ‚â• 2 transactions has a deadlock if each transaction $T$ in $S$ is waiting for some item that is locked by another transaction in $S$.

![[Pasted image 20240523163310.png | center | 200]]
### Deadlock Detection
Detect deadlock by timeout. If the system waits for a transaction $T$ longer than a predefined threshold, abort $T$ and then restart $T$. Drawback: no *perfect* time limit.

Detect deadlock with a wait-for graph. A set $S$ of transactions has a deadlock if there is a cycle in the wait-for graph of S.
![[Pasted image 20240523163415.png | center | 600]]

Maintaining and checking a wait-for graph is a valid but very expensive method of deadlock detection 

### Deadlock Recovery
When a deadlock is detected, some transactions will have to be rolled back to allow others to compete. 

You should try choose a transaction (the victim) that gets rolled back such that it will incur the minimum cost. 

On **rollback**, you need to determine how far to roll back the transaction. 
- **Total rollback** involves aborting the entire transaction and restarting it.
- **Partial Rollback** involves rolling back the victim transaction only as far as necessary to release the lock that another transaction in the cycle is waiting for. 

**Starvation** can happen here, one solution is to never choose the oldest transaction as the victim.

**Transaction Timestamp**
Assign, for each transaction ùëá, a unique identifier ùëáùëÜ(ùëá) related to the starting time of the transaction (a smaller ùëáùëÜ(ùëá) means an older transaction).

There are two protocols to prevent both deadlock and starvation.

Let ùëá be a transaction that is requesting a lock that is currently held by transaction ùëà. 
#### Wait-die: 
If ùëáùëÜ(ùëá) < ùëáùëÜ(ùëà), let ùëá wait for the lock; otherwise, abort ùëá.  

- This is a non-preemptive scheme
- Older transaction may wait for younger one to release data item.
- Younger transactions never wait for older ones; they are rolled back instead.
- A transaction may die several times before acquiring a lock

#### Would-wait: 
If ùëáùëÜ(ùëá) < ùëáùëÜ(ùëà), abort ùëà; otherwise, let ùëá to wait for the lock.

- This is a preemptive scheme
- Older transaction wounds (forces rollback) of younger transaction instead of waiting for it.
- Younger transactions may wait for older ones.
- Fewer rollbacks than wait-die scheme.
#### Summary
All transactions will eventually compete:
- Both schemes kill young transactions in a competition of resources
- Both schemes keep original timestamp when rolling back transactions
- Both schemes ensure that older transactions have precedence over newer ones preventing starvation.
- The aborted transaction will be resumed with the original timestamp, so young transactions that are killed will eventually be old.